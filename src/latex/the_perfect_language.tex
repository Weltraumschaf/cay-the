\documentclass[a4paper,12pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{xargs}
\usepackage[pdftex,dvipsnames]{xcolor}
\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}

\newcommandx{\myfixme}[2][1=]{\todo[linecolor=red,backgroundcolor=red!25,bordercolor=red,#1]{#2}}
\newcommandx{\mytodo}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=blue,#1]{#2}}
\newcommandx{\myxxx}[2][1=]{\todo[linecolor=OliveGreen,backgroundcolor=OliveGreen!25,bordercolor=OliveGreen,#1]{#2}}

\title{A Perfect Programming Language}
\author{Sven Strittmatter}
\date{\today}

\begin{document}

\maketitle
\begin{abstract}
    This paper describes a perfect programming language. We will look at drawbacks of current programming languages. Then try to describe a programming language  without these drawbacks.
\end{abstract}
\clearpage

\tableofcontents
\clearpage

\section{Motivation}

What is my motivation behind this: Describe a new perfect programming language? As of time of writing this I have over a decade of experience in programming stuff. I also have experience in various languages: C++, PHP, JavaScript, Ruby, Perl, Java. Also I saw a lot of languages. After some disappointment about the languages I used I started to look around what others do: Go, Python, Erlang, Prolog, Lisp, ML, OCaml, Scala etc.

More and more I saw different languages and their concepts I recognised that most of them have some drawbacks and I started to think about a programming language without any of these. I'm not sure if it is possible to make such a language, but I think it is worth to think about it.

\subsection{Drawbacks and Fails}

In this section I'll collect all the drawbacks and fails already existing languages have. These are not drawbacks only because I say. All of them have some common sense in the in the community of software craftmanship, clean code developers or others working hard on better software. So the points mentioned here are quite common sense for all well exercised developers. In a later section I will describe "disappointing" things which are merely based on my opinion.

\subsubsection{Null - The Billion Dollar Fail}

In a lot of programming languages exists a concept of \verb|null|. This is sometimes called a \textit{null reference} or \textit{null pointer}. Most would have seen such a thing somewhere in their career and have a vague idea what it is: Some not initialized value. Let's have a look what Wikipedia\cite{null-wiki} says what it is:

\begin{quotation}
    In computing, a null pointer has a value reserved for indicating that the pointer does not refer to a valid object. Programs routinely use null pointers to represent conditions such as the end of a list of unknown length or the failure to perform some action; this use of null pointers can be compared to nullable types and to the Nothing value in an option type.

    A null pointer should not be confused with an uninitialized pointer: A null pointer is guaranteed to compare unequal to any pointer that points to a valid object. However, depending on the language and implementation, an uninitialized pointer may not have any such guarantee. It might compare equal to other, valid pointers; or it might compare equal to null pointers. It might do both at different times.
\end{quotation}

The first thing to recognize here is that different languages implement this concept differently. We do not want to dig to deep into these implementation details but concentrate of the perspective of a user of such languages: The problem then arises is the so called \textit{null dereferencing}. From the same Wikipedia\cite{null-wiki} article:

\begin{quotation}
    Because a null pointer does not point to a meaningful object, an attempt to dereference (ie. access the data stored at that memory location) a null pointer usually (but not always) causes a run-time error or immediate program crash.
\end{quotation}

To repeat the crucial part: ``\ldots causes a run-time error or immediate program crash''. To be clear: the problem is not a concept for a not ininitalized or not present value, rather than that dereferencing such will result in program crashes.

Lets see some brief examples of such null dereferences in various common languages:

\textbf{C/C++}:
\begin{verbatim}
    SomeType *obj = nullptr;
    obj->methodCall(); // Crashs the program.
\end{verbatim}

\textbf{Java}:
\begin{verbatim}
    SomeType obj = null;
    name.methodCall(); // Crashs the program.
\end{verbatim}

\textbf{C\#}:
\begin{verbatim}
    SomeType obj = null;
    obj.MethodCall(); // Crashs the program.
\end{verbatim}

\textbf{JavaScript}:
\begin{verbatim}
    var obj = null;
    obj.methodCall(); // Crashs the program.

    obj = {methodCall: null};
    obj.methodCall(); // Crashs the program.
\end{verbatim}

\textbf{PHP}:
\begin{verbatim}
    $obj = null;
    obj->methodCall(); // Crashs the program.    
\end{verbatim}

\textbf{Python}:
\begin{verbatim}
    obj = None
    obj.methodCall() # Crashs the program.
\end{verbatim}

\textbf{Ruby}:
\begin{verbatim}
    obj = nil
    obj.method_call # Crashs the program.
\end{verbatim}

\textbf{Perl}:
\begin{verbatim}
    my $obj;
    $obj->method_call; # Crashs the program.    
\end{verbatim}

All these examples above will compile/translate without any error, but will crash tremendously at runtime. Some might say this is not the problem and as a developer you have to deal with this issue. You have to write your program either that you do not produce such null values or you deal with them correctly. But this is easier said than done. To paraphrase Murphy's law\cite{murphys-law}: If there is the possibility to make something wrong, then someone will do it wrong at some point in time. So as a result developers tend to clutter up code with null checks (called defensive programming). Which will make the code harder to read and reason. As Kent\cite{kent-dyn-err-remediation} stated in his paper \textit{Dynamic Error Remediation: A Case Study with Null Pointer Exceptions}:

\begin{quotation}
    One insidious bug is the null pointer exception, which by its ”null” nature is hard for programmers to fix. These bugs indicate that nothing was found in memory where something should have been, giving programmers very little to work with to fix the bug besides a stack trace. Null pointer exceptions sometimes show themselves only with certain inputs, making these bugs difficult to find before deployment. \ldots, 1-2\% of developer code is devoted to identifying null objects.
\end{quotation}

Also an important argument is the economic damage done by this kind of bugs. Kent\cite{kent-dyn-err-remediation} cites the NIST that along with developer time and money spent in error checking annually cost of \$59.5 are estimated. From the origin source it is not clear that these costs are only came from only this kind of bug or from all kinds. What the inventor Tony Hoare\cite{hoare-wiki} said about null\cite{hoeare-null}:

\begin{quotation}
I call it my billion-dollar mistake. It was the invention of the null reference in 1965. At that time, I was designing the first comprehensive type system for references in an object oriented language (ALGOL W). My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn't resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.	
\end{quotation} 

Whatever the real economic amount is, the fact that this kind of bug is completely avoidable by removing null pointers is obvious. To be clear: There is no problem with the concept that a value may or may not be present. Some languages (as described later) has implemented this without null pointers. The problem with null pointers is that everything everywhere may be one and either you put lot of checking code into your software or you risk crashes. In statically typed language this also subverts the type system because every type may be null but the statically checking at compile time can't inform you about this problem. As mentioned above the problem will hit reality first at runtime. There are lot of more problems which will be introduced by null. A list of some is described by Paul Draper in his blog post \textit{The worst mistake of computer science}\cite{draper-worst-mistake-cs}.

Of course there are techniques to circumvent null pointer dereferences in such languages without cluttering up the code with lot of null checks and boiler plate code. You can void using null at all. Use empty strings or zero instead of null. Or use \textit{Null Object Pattern} is a special kind of object of your type which represent an absent value. But these are \textit{workarounds} and introduce the big caveat that a software developer need to know about. Remember yourself starting software development as a novice: You learned ab out that null thing in your language of choice and of course you used it. Why else should it be part of the language, unless to use it?

Now the interesting question is: \textit{How to deal with values which may or may not be present without introducing null pointers?} Let's look at some languages which try this:

\textbf{Objective-C}: Despite the fact that \textit{Objective-C} has null due to its inheritance to C (because it is build on top of C). It has an interesting concept called \textit{nil}. It is nearly the same as the C null (instead of \verb|(void *)0| it is \verb|(id)0|). The big difference is that you can send method calls to \textit{nil} without getting an error. The call is simply ignored and returns \textit{nil} as result. So consecutive calls will not fail. This obviates defensive programming as mentioned above. For example a if-expression like

\begin{verbatim}
    if (name != nil && [name isEqualToString:@"Hello, World!"]) { ... }
\end{verbatim}

\noindent can be simplified to

\begin{verbatim}
    if ([name isEqualToString:@"Hello, World!"]) { ... }
\end{verbatim}

\noindent So it is an opt-in procedure to ask if a value is \verb|nil|: In the special case you do not want it you can react on it, but by default the program does not crash. But \textit{Objective-C} has some drawbacks in the field of not initialized references: First it has the C null as mentioned above. This introduces the risk that it is used (if someone didn't know better). Second it is not possible to store \verb|nil| in collection types and so there is a special container type singleton for that: \verb|NSNull|. Also there is a distinction between unitialized object references (\verb|nil|) and uninitialozed class references (\verb|Nil|). This makes the whole thing complicated and error prone if someone is not familiar with the whole concept.

\textbf{Go}: Go has the philosophy that \textit{value types} should be preferred to pointer types. So a value type will never be \verb|nil| (which is the Go equivalent for \verb|null|), but a value which has all its properties set to a zero value\cite{golang-spec}. So this example will never fail

\begin{verbatim}
    var t time.Time
    t.Day()
\end{verbatim}

But there are no checks if this is done intentionally or if the developer only forgot to call a constructor function.

because the variable \verb|now| will be properly initialized to a zeroed value. But it is possible to have an equivalent to a a \textit{null pointer dereference}:

\begin{verbatim}
    var t *time.Timer = nil
    t.Reset(10) // Crashs the program.
\end{verbatim}

\textbf{Swift}:
TODO

\textbf{Haskell}:
TODO

\textbf{F\#}:
TODO

\textbf{Erlang}:
TODO

\subsubsection{Checked Exceptions}

\mytodo{Words from Andre Heilsberg (C\#)}

\subsubsection{Exceptions at All}

\mytodo{They are like goto (Javaslang)}

\subsection{Disappointing}

In this section I describe things which are very disappointing, e.g. typing boiler plate code, parens, semicolons and such. In contrast to the section before these points are merely opinion based. But I try to show why we should think about it.

\subsubsection{Annoying Braces}

\mytodo{Braces for conditions: if (condition) vs. if condition.}

\subsubsection{Unnecessary Semicolon}

\mytodo{Write text.}

\subsubsection{Too Many Special Character Methods or Operators}

Looking at Perl or Scala as a beginner you will notice a lot of strange characters in the code.
Some examples from Perl\cite{secret-perl-operators}:

\begin{itemize}
    \item Spaceship operator: \verb|<=>|
    \item Eskimo Greeting operator: \verb|}{|
    \item Goatse operator: \verb|=()=|
    \item Turtle operator: \verb|@{[]}|
    \item Inchworm operator: \verb|~~|
    \item Inchworm-On-A-Stick Operator: \verb|~-|
    \item Spacestation Operator: \verb|-+-|
    \item Venus operator: \verb|0+|
\end{itemize}

Perl is an ancient language, but modern languages also have this problem. Here some examples from Scala\cite{special-operators-scala}:

\begin{itemize}
    \item Upper, lower and view bounds: \verb|<: >: <%|
    \item Vararg expansion: \verb|_*|
    \item Many different meanings: \verb|_|
\end{itemize}

I don't want to blame Perl or Scala in particular here. Other languages does this also: Haskell, Ruby etc. Especially functional languages tend to strange characters to name functions, methods or operators. In my opinion this violates the rule that source code should be least astonishing. Of course for a professional developer this may be time saving to type three characters instead of a long function name. This argument counted decades ago when the developers only had dumb text editors. Today we all have super power driven editors or IDEs with intellisense and auto completion. So there is no reason to confuse developers without years of experience with strange characters.

\subsubsection{Missing Tools}

A lot of languages lack of appropriate tooling and it is necessary to build them first before you get productive. A perfect language must come with all necessary tools. What are necessary tools?

All languages have at least a compiler or interpreter. And mostly that's all you get. In my opinion there must be more tools for:

\begin{itemize}
    \item source code formatting
    \item create API docs and documentation
    \item run tests with coverage reports
    \item dependency management
\end{itemize}

\section{What Ideas Are Out There?}

In this section ideas and concepts of already existing languages will be described.

\subsection{Kotlin}

From a blog post from Peter Sommerhoff\cite{kotlin-sommerhoff}:

\subsubsection{Data Classes}

Simple POJOs are declared simpler. Instead of writing boiler plate like:

\begin{verbatim}
class Book {
    private String title;
    private Author author;

    public String getTitle() {
        return title;
    }
    
    public void setTitle(String title) {
        this.title = title;
    }

    public Author getAuthor() {
        return author;
    }
    
    public void setAuthor(Author author) {
        this.author = author;
    }
}
\end{verbatim}

You can write:

\begin{verbatim}
data class Book(var title: String, var author: Author) {
    // ...
}	
\end{verbatim}

\subsubsection{Smart Casts}

Instead of:

\begin{verbatim}
if (node instanceof Leaf) {
    return ((Leaf) node).symbol;
}	
\end{verbatim}

less verbose:

\begin{verbatim}
if (node is Leaf) {
    return node.symbol;
}	
\end{verbatim}

\subsubsection{Type Inference}
\mytodo{Write text.}

\subsubsection{Functional Programming}
\mytodo{Write text.}

\subsubsection{Default Arguments}
\mytodo{Write text.}

\subsubsection{Named Arguments}
\mytodo{Write text.}

\subsubsection{Final Classes}

\begin{quotation}
Next, Kotlin also supports the principle to either design for inheritance or prohibit it — because in Kotlin, you have to explicitly declare a class as open in order to inherit from it. That way, you have to remember to allow inheritance instead of having to remember to disallow it.\cite{kotlin-sommerhoff}
\end{quotation}

\section{Ideas}

\begin{itemize}
    \item \verb|unless foo| statt \verb|if !foo|
    \item type (int, float) overflows generate exceptions
    \item compiler checks for right versioning in manifest
    \item compiler does not allow shot names of identifiers
    \item \verb|finally| to execute something always at least in functions
\end{itemize}

\subsection{Source}

A source file \verb|MyModule.ct| may look like:

\begin{verbatim}
var integer foo = 23
var integer bar // is 0 by default
var integer baz = foo + bar

const snafu = "Hello !"

function doIt(Integer i) {
    ...
}

function Integer doWhat(Integer i, Integer j) {
    return i + j
    
    finally {
    	// Something which is done before function returns, e.g. clean resources.
    }
}

function Integer multiFinallies() {
    File f = new File("/foo");
    f.open();
    
    finally {
        f.close()
    }
    
    File d = new File("/tmp");
    d.open()
    
    finally {
    d.close()
    }
    
    return 42
}

var result = doWhat(foo, 42)	
\end{verbatim}

\subsection{Manifest and Versioning}

A module descriptor \verb|MyModule.mf| may look like:

\begin{verbatim}
version 1.0.0

export TypeName
export TypeName
export TypeName

Integer main(List<String> args) {
  return 0
}
\end{verbatim}

\section{Specification}

\subsection{Tooling}

A perfect language need tools. Some of them are obvious:

\begin{itemize}
    \item Interpreter: An interpreter is useful in the first steps of language development, but also useful later to provide endusers a REPL (read eval print loop) tool for playing around with the language without ramp up a whole project and build infrastructure.
    \item Compiler: Of course there must be a compiler to create byte code for a virtual machine.
    \item Virtual Machine: For interpreting byte code a virtual machine is necessary. This is implemented as register based VM.
\end{itemize}

The not so obvious tools are a level above just compiling source code.

\begin{itemize}
    \item Formatter: Most languages say not much about how to format it. Therefore almost mostly formatting is a very opinion based thing. This leads to endless discussions in projects involving more than one programmer. Thats the reason why this language provides a formatter with a default which is highly recommented to use.
    \item Tester: There is tool which executes tests automatically. Also there is a built in API for unit testing.
    \item Builder: This is a tool which compiles and links a complete module. It also runs the Tester to verify the tests. Also it manages dependencies of the built module.
\end{itemize}

\subsection{Module Packaging and Visibility}

A module is a directory containing all source code. It contains one and only one manifest file which declares basic attributes for the module:

\begin{itemize}
    \item \verb|group|: This declares the group name of the module.
    \item \verb|artifct|: This declares the artifact name of the module.
    \item \verb|version|: This declares the version of the module.
    \item \verb|namespace|: This declares the namespace base of all types in the module.
\end{itemize}

Also the manifest declares the module dependencies. Modules are referenced by an import and a module coordinate.

An example of a manifest file \verb|moduledir/Manifest.mf|:
\begin{verbatim}
    group       de.weltraumschaf
    artifact    example
    version     1.0.0
    namespace   de.weltraumschaf.example
    import      org.caythe:core:1.0.0
    import      org.caythe:testing:1.0.0
\end{verbatim}

All types declared in the root of the module directory are referenced by the package name given by the namespace declaration. All sub directories are packages. For example a class \verb|Foo| in the file \verb|moduledir/Foo.ct| will be referenced by \verb|use de.weltraumschaf.example.Foo|. A type is always declared in a single file and a single file can only declare one type. So the File \verb|Foo.ct| declares the type \verb|Foo|. In consequence it is not necessary to type the name of the type again in side the file and renaming the file result in renaming the type.

From outside modules only types with explicit \verb|export| are visible. So that other modules which import \verb|de.weltraumschaf:example:1.0.0| may see the type \verb|Foo| it must be declared exported.

Also each method which should be accessible from outside must be declared exported. Methods or types declared \verb|public| are only visible everywhere inside the module. Everything declared \verb|package| is only visible in its directory and all sub directories. So a type or method in the root module directory declaring \verb|package| has the same effect as declaring it \verb|public|. By default methods and types are private.

\begin{verbatim}
    export // Exports the type
    public // Marks the type public

    export method callableFromOtherModules() { ... }
    public method callableFromWholeModule() { ... }
    package method callableFromSameDirAndSubDirs() { ... }
    // private is the default so there is no keyword for that.
    method callableOnlyFromSelf() { ... }
\end{verbatim}

\mytodo{Describe the followed items.}:

\begin{itemize}
    \item Types
    \begin{itemize}
        \item integer: 0 by default
        \item float: 0.0 by default
        \item boolean: false by default
        \item string: empty by default
    \end{itemize} 
    \item Scopes
    \begin{itemize}
        \item Lexical Scopes
        \item Variables are only writable in current scope. What about members of classes?
    \end{itemize}
\end{itemize}

\clearpage

\begin{thebibliography}{0}
	
\bibitem{null-wiki}
    Wikipedia
    \textit{Null pointer},
    \url{https://en.wikipedia.org/wiki/Null_pointer}

\bibitem{kent-dyn-err-remediation}
    Stephen W. Kent
    \textit{Dynamic Error Remediation: A Case Study with Null Pointer Exceptions}
    \url{http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.140.2544&rep=rep1&type=pdf}

\bibitem{hoare-wiki}
	Wikipedia,
	\textit{Tony Hoare},
	\url{https://en.wikipedia.org/wiki/Tony_Hoare}
	
\bibitem{hoeare-null}
	Tony Hoare,
	\textit{Speaking at a conference in 2009},
	\url{http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare}

\bibitem{draper-worst-mistake-cs}
    Paul Draper
    \textit{The worst mistake of computer science}
    \url{https://www.lucidchart.com/techblog/2015/08/31/the-worst-mistake-of-computer-science/}

\bibitem{kotlin-sommerhoff}
 	Peter Sommerhoff,
 	\textit{Kotlin for Java Developers: 10 Features You Will Love About Kotlin}
 	\url{https://www.javacodegeeks.com/2016/05/kotlin-java-developers-10-features-will-love-kotlin.html}

\bibitem{secret-perl-operators}
	Peteris Krumin,
	\textit{Secret Perl Operators}
	\url{http://www.catonmat.net/blog/secret-perl-operators/}

\bibitem{special-operators-scala}
	Daniel C. Sobral,
	\textit{What do all of Scala's symbolic operators mean?},
	\url{http://stackoverflow.com/questions/7888944/what-do-all-of-scalas-symbolic-operators-mean}
	
\bibitem{murphys-law}
    Wikipedia
    \textit{Murphy's law}
    \url{https://en.wikipedia.org/wiki/Murphy's_law}

\bibitem{golang-spec}
    \textit{The Go Programming Language Specification}
    \url{https://golang.org/ref/spec}
\end{thebibliography}

\end{document}