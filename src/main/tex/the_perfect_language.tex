\documentclass[a4paper,12pt]{article}

\title{The Perfect Programming Language}
\author{Sven Strittmatter}
\date{\today}

\begin{document}
\maketitle
\abstract{This paper describes the perfect programming language. We will look at drawback of current programming languages. Then try to describe a programming language  without these drawbacks.}
\newpage

\tableofcontents
\newpage

\section{Motivation}

What is my motivation behind this: Creating a new perfect programming language? As of time of writing this I have over a decade of experience in programming stuff. I also have experience in various languages: C++, PHP, JavaScript, Ruby, Perl, Java. I also seen a lot of Languages. After some disappointment about the languages I used I looked around what others do: Go, Python, Erlang, Prolog, Lisp, ML, OCaml, Scala etc.

More and more I saw different languages and their concepts I recognised that most of them have some drawbacks and I started to think about a programming language without any drawback. I'm not shure if it is possible to make such a language, but I think it is worth to think about it.

\subsection{Drawbacks and Fails}

In this section I'll collect all the drawbacks and fails already existing languages have.

\subsubsection{TODO}

\subsection*{Disappointing}

In this section I describe things which are very disappointing, e.g. typing boiler plate code.

\subsubsection{TODO}

\section{Ideas}

\begin{itemize}
	\item \texttt{unless foo} statt \texttt{if !foo}
	\item type (int, float) overflows generate exceptions
	\item compiler checks for right versioning in manifest
	\item compiler does not allow shot names of identifiers
	\item \texttt{finally} to execute something always at least in functions
\end{itemize}

\subsection{Source}

A source file \texttt{MyModule.ct} may look like:

\begin{verbatim}
var integer foo = 23
var integer bar // is 0 by default
var integer baz = foo + bar

const snafu = "Hello !"

function doIt(Integer i) {
    ...
}

function Integer doWhat(Integer i, Integer j) {
    return i + j
    
    finally {
    	// Something which is done before function returns, e.g. clean resources.
    }
}

function Integer multiFinallies() {
	File f = new File("/foo");
	f.open();
	
	finally {
		f.close()
	}
	
	File d = new File("/tmp");
	d.open()
	
	finally {
		d.close()
	}
	
	return 42
}

var result = doWhat(foo, 42)	
\end{verbatim}

\subsection{Manifest and Versioning}

A module descriptor \texttt{MyModule.mf} may look like:

\begin{verbatim}
version 1.0.0

export TypeName
export TypeName
export TypeName

Integer main(List<String> args) {
  return 0
}
\end{verbatim}

\section{Specification}
\begin{itemize}
	\item Types
  	\begin{itemize}
  		\item integer: 0 by default
  		\item float: 0.0 by default
  		\item boolean: false by default
  		\item string: empty by default
  	\end{itemize} 
  	\item Scopes
  	\begin{itemize}
  		\item Lexical Scopes
  		\item Variables are only writable in current scope. What about members of classes?
  	\end{itemize}
\end{itemize}

\end{document}