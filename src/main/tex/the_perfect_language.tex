\documentclass[a4paper,12pt]{article}

\usepackage{hyperref}

\title{The Perfect Programming Language}
\author{Sven Strittmatter}
\date{\today}

\begin{document}
\maketitle
\abstract{This paper describes the perfect programming language. We will look at drawback of current programming languages. Then try to describe a programming language  without these drawbacks.}
\newpage

\tableofcontents
\newpage

\section{Motivation}

What is my motivation behind this: Creating a new perfect programming language? As of time of writing this I have over a decade of experience in programming stuff. I also have experience in various languages: C++, PHP, JavaScript, Ruby, Perl, Java. I also seen a lot of Languages. After some disappointment about the languages I used I looked around what others do: Go, Python, Erlang, Prolog, Lisp, ML, OCaml, Scala etc.

More and more I saw different languages and their concepts I recognised that most of them have some drawbacks and I started to think about a programming language without any drawback. I'm not shure if it is possible to make such a language, but I think it is worth to think about it.

\subsection{Drawbacks and Fails}

In this section I'll collect all the drawbacks and fails already existing languages have.

\subsubsection{Null - The Billion Dollar Fail}

What the inventor Tony Hoare\cite{hoare-wiki} said about null\cite{hoeare-null}:

\begin{quotation}
I call it my billion-dollar mistake. It was the invention of the null reference in 1965. At that time, I was designing the first comprehensive type system for references in an object oriented language (ALGOL W). My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn't resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.	
\end{quotation} 

TODO

\subsection{Disappointing}

In this section I describe things which are very disappointing, e.g. typing boiler plate code.

\subsubsection{Annoying Braces}

TODO: Breaces for conditions: if (cond) vs. if cond

\subsubsection{Unecessary Semicolon}

TODO

\section{What Ideas Are Out There?}

In this section ideas and concepts of already existing languages will be described.

\subsection{Kotlin}

From a blog post from Peter Sommerhoff\cite{kotlin-sommerhoff}:

\subsubsection{Data Classes}

Simple POJOs are declared simpler. Instead of writing boiler plate like:

\begin{verbatim}
class Book {
    private String title;
    private Author author;

    public String getTitle() {
        return title;
    }
    
    public void setTitle(String title) {
        this.title = title;
    }

    public Author getAuthor() {
        return author;
    }
    
    public void setAuthor(Author author) {
        this.author = author;
    }
}
\end{verbatim}

You can write:

\begin{verbatim}
data class Book(var title: String, var author: Author) {
    // ...
}	
\end{verbatim}

\subsubsection{Smart Casts}

Instead of:

\begin{verbatim}
if (node instanceof Leaf) {
    return ((Leaf) node).symbol;
}	
\end{verbatim}

less verbose:

\begin{verbatim}
if (node is Leaf) {
    return node.symbol;
}	
\end{verbatim}

\subsubsection{Type Inference}
TODO

\subsubsection{Functional Programming}
TODO

\subsubsection{Default Arguments}
TODO

\subsubsection{Named Arguments}
TODO

\subsubsection{Final Classes}

\begin{quotation}
Next, Kotlin also supports the principle to either design for inheritance or prohibit it â€” because in Kotlin, you have to explicitly declare a class as open in order to inherit from it. That way, you have to remember to allow inheritance instead of having to remember to disallow it.\cite{kotlin-sommerhoff}
\end{quotation}

\section{Ideas}

\begin{itemize}
	\item \texttt{unless foo} statt \texttt{if !foo}
	\item type (int, float) overflows generate exceptions
	\item compiler checks for right versioning in manifest
	\item compiler does not allow shot names of identifiers
	\item \texttt{finally} to execute something always at least in functions
\end{itemize}

\subsection{Source}

A source file \texttt{MyModule.ct} may look like:

\begin{verbatim}
var integer foo = 23
var integer bar // is 0 by default
var integer baz = foo + bar

const snafu = "Hello !"

function doIt(Integer i) {
    ...
}

function Integer doWhat(Integer i, Integer j) {
    return i + j
    
    finally {
    	// Something which is done before function returns, e.g. clean resources.
    }
}

function Integer multiFinallies() {
    File f = new File("/foo");
    f.open();
    
    finally {
        f.close()
    }
    
    File d = new File("/tmp");
    d.open()
    
    finally {
    d.close()
    }
    
    return 42
}

var result = doWhat(foo, 42)	
\end{verbatim}

\subsection{Manifest and Versioning}

A module descriptor \texttt{MyModule.mf} may look like:

\begin{verbatim}
version 1.0.0

export TypeName
export TypeName
export TypeName

Integer main(List<String> args) {
  return 0
}
\end{verbatim}

\section{Specification}
\begin{itemize}
	\item Types
  	\begin{itemize}
  		\item integer: 0 by default
  		\item float: 0.0 by default
  		\item boolean: false by default
  		\item string: empty by default
  	\end{itemize} 
  	\item Scopes
  	\begin{itemize}
  		\item Lexical Scopes
  		\item Variables are only writable in current scope. What about members of classes?
  	\end{itemize}
\end{itemize}

\newpage
\begin{thebibliography}{56}
\bibitem{hoare-wiki}
	Wikipedia,
	\emph{Tony Hoare},
	\url{https://en.wikipedia.org/wiki/Tony_Hoare}
	
\bibitem{hoeare-null}
	Tony Hoare,
	\emph{Speaking at a conference in 2009},
	\url{http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare}
	
\bibitem{kotlin-sommerhoff}
 	Peter Sommerhoff,
 	\emph{Kotlin for Java Developers: 10 Features You Will Love About Kotlin}
 	\url{https://www.javacodegeeks.com/2016/05/kotlin-java-developers-10-features-will-love-kotlin.html}
\end{thebibliography}
\end{document}